// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package reminder_aggregate

//go:generate minimock -i github.com/Roum1212/todo/internal/domain/aggregate/reminder.ReminderRepository -o reminder_repository_mock_test.go -n ReminderRepositoryMock -p reminder_aggregate

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	reminder_id_model "github.com/Roum1212/todo/internal/domain/model/reminder-id"
	"github.com/gojuno/minimock/v3"
)

// ReminderRepositoryMock implements ReminderRepository
type ReminderRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcDeleteReminder          func(ctx context.Context, reminderID reminder_id_model.ReminderID) (err error)
	funcDeleteReminderOrigin    string
	inspectFuncDeleteReminder   func(ctx context.Context, reminderID reminder_id_model.ReminderID)
	afterDeleteReminderCounter  uint64
	beforeDeleteReminderCounter uint64
	DeleteReminderMock          mReminderRepositoryMockDeleteReminder

	funcGetAllReminders          func(ctx context.Context) (ra1 []Reminder, err error)
	funcGetAllRemindersOrigin    string
	inspectFuncGetAllReminders   func(ctx context.Context)
	afterGetAllRemindersCounter  uint64
	beforeGetAllRemindersCounter uint64
	GetAllRemindersMock          mReminderRepositoryMockGetAllReminders

	funcGetReminderByID          func(ctx context.Context, reminderID reminder_id_model.ReminderID) (r1 Reminder, err error)
	funcGetReminderByIDOrigin    string
	inspectFuncGetReminderByID   func(ctx context.Context, reminderID reminder_id_model.ReminderID)
	afterGetReminderByIDCounter  uint64
	beforeGetReminderByIDCounter uint64
	GetReminderByIDMock          mReminderRepositoryMockGetReminderByID

	funcSaveReminder          func(ctx context.Context, reminder Reminder) (err error)
	funcSaveReminderOrigin    string
	inspectFuncSaveReminder   func(ctx context.Context, reminder Reminder)
	afterSaveReminderCounter  uint64
	beforeSaveReminderCounter uint64
	SaveReminderMock          mReminderRepositoryMockSaveReminder
}

// NewReminderRepositoryMock returns a mock for ReminderRepository
func NewReminderRepositoryMock(t minimock.Tester) *ReminderRepositoryMock {
	m := &ReminderRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.DeleteReminderMock = mReminderRepositoryMockDeleteReminder{mock: m}
	m.DeleteReminderMock.callArgs = []*ReminderRepositoryMockDeleteReminderParams{}

	m.GetAllRemindersMock = mReminderRepositoryMockGetAllReminders{mock: m}
	m.GetAllRemindersMock.callArgs = []*ReminderRepositoryMockGetAllRemindersParams{}

	m.GetReminderByIDMock = mReminderRepositoryMockGetReminderByID{mock: m}
	m.GetReminderByIDMock.callArgs = []*ReminderRepositoryMockGetReminderByIDParams{}

	m.SaveReminderMock = mReminderRepositoryMockSaveReminder{mock: m}
	m.SaveReminderMock.callArgs = []*ReminderRepositoryMockSaveReminderParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mReminderRepositoryMockDeleteReminder struct {
	optional           bool
	mock               *ReminderRepositoryMock
	defaultExpectation *ReminderRepositoryMockDeleteReminderExpectation
	expectations       []*ReminderRepositoryMockDeleteReminderExpectation

	callArgs []*ReminderRepositoryMockDeleteReminderParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ReminderRepositoryMockDeleteReminderExpectation specifies expectation struct of the ReminderRepository.DeleteReminder
type ReminderRepositoryMockDeleteReminderExpectation struct {
	mock               *ReminderRepositoryMock
	params             *ReminderRepositoryMockDeleteReminderParams
	paramPtrs          *ReminderRepositoryMockDeleteReminderParamPtrs
	expectationOrigins ReminderRepositoryMockDeleteReminderExpectationOrigins
	results            *ReminderRepositoryMockDeleteReminderResults
	returnOrigin       string
	Counter            uint64
}

// ReminderRepositoryMockDeleteReminderParams contains parameters of the ReminderRepository.DeleteReminder
type ReminderRepositoryMockDeleteReminderParams struct {
	ctx        context.Context
	reminderID reminder_id_model.ReminderID
}

// ReminderRepositoryMockDeleteReminderParamPtrs contains pointers to parameters of the ReminderRepository.DeleteReminder
type ReminderRepositoryMockDeleteReminderParamPtrs struct {
	ctx        *context.Context
	reminderID *reminder_id_model.ReminderID
}

// ReminderRepositoryMockDeleteReminderResults contains results of the ReminderRepository.DeleteReminder
type ReminderRepositoryMockDeleteReminderResults struct {
	err error
}

// ReminderRepositoryMockDeleteReminderOrigins contains origins of expectations of the ReminderRepository.DeleteReminder
type ReminderRepositoryMockDeleteReminderExpectationOrigins struct {
	origin           string
	originCtx        string
	originReminderID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteReminder *mReminderRepositoryMockDeleteReminder) Optional() *mReminderRepositoryMockDeleteReminder {
	mmDeleteReminder.optional = true
	return mmDeleteReminder
}

// Expect sets up expected params for ReminderRepository.DeleteReminder
func (mmDeleteReminder *mReminderRepositoryMockDeleteReminder) Expect(ctx context.Context, reminderID reminder_id_model.ReminderID) *mReminderRepositoryMockDeleteReminder {
	if mmDeleteReminder.mock.funcDeleteReminder != nil {
		mmDeleteReminder.mock.t.Fatalf("ReminderRepositoryMock.DeleteReminder mock is already set by Set")
	}

	if mmDeleteReminder.defaultExpectation == nil {
		mmDeleteReminder.defaultExpectation = &ReminderRepositoryMockDeleteReminderExpectation{}
	}

	if mmDeleteReminder.defaultExpectation.paramPtrs != nil {
		mmDeleteReminder.mock.t.Fatalf("ReminderRepositoryMock.DeleteReminder mock is already set by ExpectParams functions")
	}

	mmDeleteReminder.defaultExpectation.params = &ReminderRepositoryMockDeleteReminderParams{ctx, reminderID}
	mmDeleteReminder.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteReminder.expectations {
		if minimock.Equal(e.params, mmDeleteReminder.defaultExpectation.params) {
			mmDeleteReminder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteReminder.defaultExpectation.params)
		}
	}

	return mmDeleteReminder
}

// ExpectCtxParam1 sets up expected param ctx for ReminderRepository.DeleteReminder
func (mmDeleteReminder *mReminderRepositoryMockDeleteReminder) ExpectCtxParam1(ctx context.Context) *mReminderRepositoryMockDeleteReminder {
	if mmDeleteReminder.mock.funcDeleteReminder != nil {
		mmDeleteReminder.mock.t.Fatalf("ReminderRepositoryMock.DeleteReminder mock is already set by Set")
	}

	if mmDeleteReminder.defaultExpectation == nil {
		mmDeleteReminder.defaultExpectation = &ReminderRepositoryMockDeleteReminderExpectation{}
	}

	if mmDeleteReminder.defaultExpectation.params != nil {
		mmDeleteReminder.mock.t.Fatalf("ReminderRepositoryMock.DeleteReminder mock is already set by Expect")
	}

	if mmDeleteReminder.defaultExpectation.paramPtrs == nil {
		mmDeleteReminder.defaultExpectation.paramPtrs = &ReminderRepositoryMockDeleteReminderParamPtrs{}
	}
	mmDeleteReminder.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteReminder.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteReminder
}

// ExpectReminderIDParam2 sets up expected param reminderID for ReminderRepository.DeleteReminder
func (mmDeleteReminder *mReminderRepositoryMockDeleteReminder) ExpectReminderIDParam2(reminderID reminder_id_model.ReminderID) *mReminderRepositoryMockDeleteReminder {
	if mmDeleteReminder.mock.funcDeleteReminder != nil {
		mmDeleteReminder.mock.t.Fatalf("ReminderRepositoryMock.DeleteReminder mock is already set by Set")
	}

	if mmDeleteReminder.defaultExpectation == nil {
		mmDeleteReminder.defaultExpectation = &ReminderRepositoryMockDeleteReminderExpectation{}
	}

	if mmDeleteReminder.defaultExpectation.params != nil {
		mmDeleteReminder.mock.t.Fatalf("ReminderRepositoryMock.DeleteReminder mock is already set by Expect")
	}

	if mmDeleteReminder.defaultExpectation.paramPtrs == nil {
		mmDeleteReminder.defaultExpectation.paramPtrs = &ReminderRepositoryMockDeleteReminderParamPtrs{}
	}
	mmDeleteReminder.defaultExpectation.paramPtrs.reminderID = &reminderID
	mmDeleteReminder.defaultExpectation.expectationOrigins.originReminderID = minimock.CallerInfo(1)

	return mmDeleteReminder
}

// Inspect accepts an inspector function that has same arguments as the ReminderRepository.DeleteReminder
func (mmDeleteReminder *mReminderRepositoryMockDeleteReminder) Inspect(f func(ctx context.Context, reminderID reminder_id_model.ReminderID)) *mReminderRepositoryMockDeleteReminder {
	if mmDeleteReminder.mock.inspectFuncDeleteReminder != nil {
		mmDeleteReminder.mock.t.Fatalf("Inspect function is already set for ReminderRepositoryMock.DeleteReminder")
	}

	mmDeleteReminder.mock.inspectFuncDeleteReminder = f

	return mmDeleteReminder
}

// Return sets up results that will be returned by ReminderRepository.DeleteReminder
func (mmDeleteReminder *mReminderRepositoryMockDeleteReminder) Return(err error) *ReminderRepositoryMock {
	if mmDeleteReminder.mock.funcDeleteReminder != nil {
		mmDeleteReminder.mock.t.Fatalf("ReminderRepositoryMock.DeleteReminder mock is already set by Set")
	}

	if mmDeleteReminder.defaultExpectation == nil {
		mmDeleteReminder.defaultExpectation = &ReminderRepositoryMockDeleteReminderExpectation{mock: mmDeleteReminder.mock}
	}
	mmDeleteReminder.defaultExpectation.results = &ReminderRepositoryMockDeleteReminderResults{err}
	mmDeleteReminder.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteReminder.mock
}

// Set uses given function f to mock the ReminderRepository.DeleteReminder method
func (mmDeleteReminder *mReminderRepositoryMockDeleteReminder) Set(f func(ctx context.Context, reminderID reminder_id_model.ReminderID) (err error)) *ReminderRepositoryMock {
	if mmDeleteReminder.defaultExpectation != nil {
		mmDeleteReminder.mock.t.Fatalf("Default expectation is already set for the ReminderRepository.DeleteReminder method")
	}

	if len(mmDeleteReminder.expectations) > 0 {
		mmDeleteReminder.mock.t.Fatalf("Some expectations are already set for the ReminderRepository.DeleteReminder method")
	}

	mmDeleteReminder.mock.funcDeleteReminder = f
	mmDeleteReminder.mock.funcDeleteReminderOrigin = minimock.CallerInfo(1)
	return mmDeleteReminder.mock
}

// When sets expectation for the ReminderRepository.DeleteReminder which will trigger the result defined by the following
// Then helper
func (mmDeleteReminder *mReminderRepositoryMockDeleteReminder) When(ctx context.Context, reminderID reminder_id_model.ReminderID) *ReminderRepositoryMockDeleteReminderExpectation {
	if mmDeleteReminder.mock.funcDeleteReminder != nil {
		mmDeleteReminder.mock.t.Fatalf("ReminderRepositoryMock.DeleteReminder mock is already set by Set")
	}

	expectation := &ReminderRepositoryMockDeleteReminderExpectation{
		mock:               mmDeleteReminder.mock,
		params:             &ReminderRepositoryMockDeleteReminderParams{ctx, reminderID},
		expectationOrigins: ReminderRepositoryMockDeleteReminderExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteReminder.expectations = append(mmDeleteReminder.expectations, expectation)
	return expectation
}

// Then sets up ReminderRepository.DeleteReminder return parameters for the expectation previously defined by the When method
func (e *ReminderRepositoryMockDeleteReminderExpectation) Then(err error) *ReminderRepositoryMock {
	e.results = &ReminderRepositoryMockDeleteReminderResults{err}
	return e.mock
}

// Times sets number of times ReminderRepository.DeleteReminder should be invoked
func (mmDeleteReminder *mReminderRepositoryMockDeleteReminder) Times(n uint64) *mReminderRepositoryMockDeleteReminder {
	if n == 0 {
		mmDeleteReminder.mock.t.Fatalf("Times of ReminderRepositoryMock.DeleteReminder mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteReminder.expectedInvocations, n)
	mmDeleteReminder.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteReminder
}

func (mmDeleteReminder *mReminderRepositoryMockDeleteReminder) invocationsDone() bool {
	if len(mmDeleteReminder.expectations) == 0 && mmDeleteReminder.defaultExpectation == nil && mmDeleteReminder.mock.funcDeleteReminder == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteReminder.mock.afterDeleteReminderCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteReminder.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteReminder implements ReminderRepository
func (mmDeleteReminder *ReminderRepositoryMock) DeleteReminder(ctx context.Context, reminderID reminder_id_model.ReminderID) (err error) {
	mm_atomic.AddUint64(&mmDeleteReminder.beforeDeleteReminderCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteReminder.afterDeleteReminderCounter, 1)

	mmDeleteReminder.t.Helper()

	if mmDeleteReminder.inspectFuncDeleteReminder != nil {
		mmDeleteReminder.inspectFuncDeleteReminder(ctx, reminderID)
	}

	mm_params := ReminderRepositoryMockDeleteReminderParams{ctx, reminderID}

	// Record call args
	mmDeleteReminder.DeleteReminderMock.mutex.Lock()
	mmDeleteReminder.DeleteReminderMock.callArgs = append(mmDeleteReminder.DeleteReminderMock.callArgs, &mm_params)
	mmDeleteReminder.DeleteReminderMock.mutex.Unlock()

	for _, e := range mmDeleteReminder.DeleteReminderMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteReminder.DeleteReminderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteReminder.DeleteReminderMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteReminder.DeleteReminderMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteReminder.DeleteReminderMock.defaultExpectation.paramPtrs

		mm_got := ReminderRepositoryMockDeleteReminderParams{ctx, reminderID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteReminder.t.Errorf("ReminderRepositoryMock.DeleteReminder got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteReminder.DeleteReminderMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.reminderID != nil && !minimock.Equal(*mm_want_ptrs.reminderID, mm_got.reminderID) {
				mmDeleteReminder.t.Errorf("ReminderRepositoryMock.DeleteReminder got unexpected parameter reminderID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteReminder.DeleteReminderMock.defaultExpectation.expectationOrigins.originReminderID, *mm_want_ptrs.reminderID, mm_got.reminderID, minimock.Diff(*mm_want_ptrs.reminderID, mm_got.reminderID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteReminder.t.Errorf("ReminderRepositoryMock.DeleteReminder got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteReminder.DeleteReminderMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteReminder.DeleteReminderMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteReminder.t.Fatal("No results are set for the ReminderRepositoryMock.DeleteReminder")
		}
		return (*mm_results).err
	}
	if mmDeleteReminder.funcDeleteReminder != nil {
		return mmDeleteReminder.funcDeleteReminder(ctx, reminderID)
	}
	mmDeleteReminder.t.Fatalf("Unexpected call to ReminderRepositoryMock.DeleteReminder. %v %v", ctx, reminderID)
	return
}

// DeleteReminderAfterCounter returns a count of finished ReminderRepositoryMock.DeleteReminder invocations
func (mmDeleteReminder *ReminderRepositoryMock) DeleteReminderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteReminder.afterDeleteReminderCounter)
}

// DeleteReminderBeforeCounter returns a count of ReminderRepositoryMock.DeleteReminder invocations
func (mmDeleteReminder *ReminderRepositoryMock) DeleteReminderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteReminder.beforeDeleteReminderCounter)
}

// Calls returns a list of arguments used in each call to ReminderRepositoryMock.DeleteReminder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteReminder *mReminderRepositoryMockDeleteReminder) Calls() []*ReminderRepositoryMockDeleteReminderParams {
	mmDeleteReminder.mutex.RLock()

	argCopy := make([]*ReminderRepositoryMockDeleteReminderParams, len(mmDeleteReminder.callArgs))
	copy(argCopy, mmDeleteReminder.callArgs)

	mmDeleteReminder.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteReminderDone returns true if the count of the DeleteReminder invocations corresponds
// the number of defined expectations
func (m *ReminderRepositoryMock) MinimockDeleteReminderDone() bool {
	if m.DeleteReminderMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteReminderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteReminderMock.invocationsDone()
}

// MinimockDeleteReminderInspect logs each unmet expectation
func (m *ReminderRepositoryMock) MinimockDeleteReminderInspect() {
	for _, e := range m.DeleteReminderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ReminderRepositoryMock.DeleteReminder at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteReminderCounter := mm_atomic.LoadUint64(&m.afterDeleteReminderCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteReminderMock.defaultExpectation != nil && afterDeleteReminderCounter < 1 {
		if m.DeleteReminderMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ReminderRepositoryMock.DeleteReminder at\n%s", m.DeleteReminderMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ReminderRepositoryMock.DeleteReminder at\n%s with params: %#v", m.DeleteReminderMock.defaultExpectation.expectationOrigins.origin, *m.DeleteReminderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteReminder != nil && afterDeleteReminderCounter < 1 {
		m.t.Errorf("Expected call to ReminderRepositoryMock.DeleteReminder at\n%s", m.funcDeleteReminderOrigin)
	}

	if !m.DeleteReminderMock.invocationsDone() && afterDeleteReminderCounter > 0 {
		m.t.Errorf("Expected %d calls to ReminderRepositoryMock.DeleteReminder at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteReminderMock.expectedInvocations), m.DeleteReminderMock.expectedInvocationsOrigin, afterDeleteReminderCounter)
	}
}

type mReminderRepositoryMockGetAllReminders struct {
	optional           bool
	mock               *ReminderRepositoryMock
	defaultExpectation *ReminderRepositoryMockGetAllRemindersExpectation
	expectations       []*ReminderRepositoryMockGetAllRemindersExpectation

	callArgs []*ReminderRepositoryMockGetAllRemindersParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ReminderRepositoryMockGetAllRemindersExpectation specifies expectation struct of the ReminderRepository.GetAllReminders
type ReminderRepositoryMockGetAllRemindersExpectation struct {
	mock               *ReminderRepositoryMock
	params             *ReminderRepositoryMockGetAllRemindersParams
	paramPtrs          *ReminderRepositoryMockGetAllRemindersParamPtrs
	expectationOrigins ReminderRepositoryMockGetAllRemindersExpectationOrigins
	results            *ReminderRepositoryMockGetAllRemindersResults
	returnOrigin       string
	Counter            uint64
}

// ReminderRepositoryMockGetAllRemindersParams contains parameters of the ReminderRepository.GetAllReminders
type ReminderRepositoryMockGetAllRemindersParams struct {
	ctx context.Context
}

// ReminderRepositoryMockGetAllRemindersParamPtrs contains pointers to parameters of the ReminderRepository.GetAllReminders
type ReminderRepositoryMockGetAllRemindersParamPtrs struct {
	ctx *context.Context
}

// ReminderRepositoryMockGetAllRemindersResults contains results of the ReminderRepository.GetAllReminders
type ReminderRepositoryMockGetAllRemindersResults struct {
	ra1 []Reminder
	err error
}

// ReminderRepositoryMockGetAllRemindersOrigins contains origins of expectations of the ReminderRepository.GetAllReminders
type ReminderRepositoryMockGetAllRemindersExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetAllReminders *mReminderRepositoryMockGetAllReminders) Optional() *mReminderRepositoryMockGetAllReminders {
	mmGetAllReminders.optional = true
	return mmGetAllReminders
}

// Expect sets up expected params for ReminderRepository.GetAllReminders
func (mmGetAllReminders *mReminderRepositoryMockGetAllReminders) Expect(ctx context.Context) *mReminderRepositoryMockGetAllReminders {
	if mmGetAllReminders.mock.funcGetAllReminders != nil {
		mmGetAllReminders.mock.t.Fatalf("ReminderRepositoryMock.GetAllReminders mock is already set by Set")
	}

	if mmGetAllReminders.defaultExpectation == nil {
		mmGetAllReminders.defaultExpectation = &ReminderRepositoryMockGetAllRemindersExpectation{}
	}

	if mmGetAllReminders.defaultExpectation.paramPtrs != nil {
		mmGetAllReminders.mock.t.Fatalf("ReminderRepositoryMock.GetAllReminders mock is already set by ExpectParams functions")
	}

	mmGetAllReminders.defaultExpectation.params = &ReminderRepositoryMockGetAllRemindersParams{ctx}
	mmGetAllReminders.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetAllReminders.expectations {
		if minimock.Equal(e.params, mmGetAllReminders.defaultExpectation.params) {
			mmGetAllReminders.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetAllReminders.defaultExpectation.params)
		}
	}

	return mmGetAllReminders
}

// ExpectCtxParam1 sets up expected param ctx for ReminderRepository.GetAllReminders
func (mmGetAllReminders *mReminderRepositoryMockGetAllReminders) ExpectCtxParam1(ctx context.Context) *mReminderRepositoryMockGetAllReminders {
	if mmGetAllReminders.mock.funcGetAllReminders != nil {
		mmGetAllReminders.mock.t.Fatalf("ReminderRepositoryMock.GetAllReminders mock is already set by Set")
	}

	if mmGetAllReminders.defaultExpectation == nil {
		mmGetAllReminders.defaultExpectation = &ReminderRepositoryMockGetAllRemindersExpectation{}
	}

	if mmGetAllReminders.defaultExpectation.params != nil {
		mmGetAllReminders.mock.t.Fatalf("ReminderRepositoryMock.GetAllReminders mock is already set by Expect")
	}

	if mmGetAllReminders.defaultExpectation.paramPtrs == nil {
		mmGetAllReminders.defaultExpectation.paramPtrs = &ReminderRepositoryMockGetAllRemindersParamPtrs{}
	}
	mmGetAllReminders.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetAllReminders.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetAllReminders
}

// Inspect accepts an inspector function that has same arguments as the ReminderRepository.GetAllReminders
func (mmGetAllReminders *mReminderRepositoryMockGetAllReminders) Inspect(f func(ctx context.Context)) *mReminderRepositoryMockGetAllReminders {
	if mmGetAllReminders.mock.inspectFuncGetAllReminders != nil {
		mmGetAllReminders.mock.t.Fatalf("Inspect function is already set for ReminderRepositoryMock.GetAllReminders")
	}

	mmGetAllReminders.mock.inspectFuncGetAllReminders = f

	return mmGetAllReminders
}

// Return sets up results that will be returned by ReminderRepository.GetAllReminders
func (mmGetAllReminders *mReminderRepositoryMockGetAllReminders) Return(ra1 []Reminder, err error) *ReminderRepositoryMock {
	if mmGetAllReminders.mock.funcGetAllReminders != nil {
		mmGetAllReminders.mock.t.Fatalf("ReminderRepositoryMock.GetAllReminders mock is already set by Set")
	}

	if mmGetAllReminders.defaultExpectation == nil {
		mmGetAllReminders.defaultExpectation = &ReminderRepositoryMockGetAllRemindersExpectation{mock: mmGetAllReminders.mock}
	}
	mmGetAllReminders.defaultExpectation.results = &ReminderRepositoryMockGetAllRemindersResults{ra1, err}
	mmGetAllReminders.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetAllReminders.mock
}

// Set uses given function f to mock the ReminderRepository.GetAllReminders method
func (mmGetAllReminders *mReminderRepositoryMockGetAllReminders) Set(f func(ctx context.Context) (ra1 []Reminder, err error)) *ReminderRepositoryMock {
	if mmGetAllReminders.defaultExpectation != nil {
		mmGetAllReminders.mock.t.Fatalf("Default expectation is already set for the ReminderRepository.GetAllReminders method")
	}

	if len(mmGetAllReminders.expectations) > 0 {
		mmGetAllReminders.mock.t.Fatalf("Some expectations are already set for the ReminderRepository.GetAllReminders method")
	}

	mmGetAllReminders.mock.funcGetAllReminders = f
	mmGetAllReminders.mock.funcGetAllRemindersOrigin = minimock.CallerInfo(1)
	return mmGetAllReminders.mock
}

// When sets expectation for the ReminderRepository.GetAllReminders which will trigger the result defined by the following
// Then helper
func (mmGetAllReminders *mReminderRepositoryMockGetAllReminders) When(ctx context.Context) *ReminderRepositoryMockGetAllRemindersExpectation {
	if mmGetAllReminders.mock.funcGetAllReminders != nil {
		mmGetAllReminders.mock.t.Fatalf("ReminderRepositoryMock.GetAllReminders mock is already set by Set")
	}

	expectation := &ReminderRepositoryMockGetAllRemindersExpectation{
		mock:               mmGetAllReminders.mock,
		params:             &ReminderRepositoryMockGetAllRemindersParams{ctx},
		expectationOrigins: ReminderRepositoryMockGetAllRemindersExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetAllReminders.expectations = append(mmGetAllReminders.expectations, expectation)
	return expectation
}

// Then sets up ReminderRepository.GetAllReminders return parameters for the expectation previously defined by the When method
func (e *ReminderRepositoryMockGetAllRemindersExpectation) Then(ra1 []Reminder, err error) *ReminderRepositoryMock {
	e.results = &ReminderRepositoryMockGetAllRemindersResults{ra1, err}
	return e.mock
}

// Times sets number of times ReminderRepository.GetAllReminders should be invoked
func (mmGetAllReminders *mReminderRepositoryMockGetAllReminders) Times(n uint64) *mReminderRepositoryMockGetAllReminders {
	if n == 0 {
		mmGetAllReminders.mock.t.Fatalf("Times of ReminderRepositoryMock.GetAllReminders mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetAllReminders.expectedInvocations, n)
	mmGetAllReminders.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetAllReminders
}

func (mmGetAllReminders *mReminderRepositoryMockGetAllReminders) invocationsDone() bool {
	if len(mmGetAllReminders.expectations) == 0 && mmGetAllReminders.defaultExpectation == nil && mmGetAllReminders.mock.funcGetAllReminders == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetAllReminders.mock.afterGetAllRemindersCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetAllReminders.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetAllReminders implements ReminderRepository
func (mmGetAllReminders *ReminderRepositoryMock) GetAllReminders(ctx context.Context) (ra1 []Reminder, err error) {
	mm_atomic.AddUint64(&mmGetAllReminders.beforeGetAllRemindersCounter, 1)
	defer mm_atomic.AddUint64(&mmGetAllReminders.afterGetAllRemindersCounter, 1)

	mmGetAllReminders.t.Helper()

	if mmGetAllReminders.inspectFuncGetAllReminders != nil {
		mmGetAllReminders.inspectFuncGetAllReminders(ctx)
	}

	mm_params := ReminderRepositoryMockGetAllRemindersParams{ctx}

	// Record call args
	mmGetAllReminders.GetAllRemindersMock.mutex.Lock()
	mmGetAllReminders.GetAllRemindersMock.callArgs = append(mmGetAllReminders.GetAllRemindersMock.callArgs, &mm_params)
	mmGetAllReminders.GetAllRemindersMock.mutex.Unlock()

	for _, e := range mmGetAllReminders.GetAllRemindersMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ra1, e.results.err
		}
	}

	if mmGetAllReminders.GetAllRemindersMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetAllReminders.GetAllRemindersMock.defaultExpectation.Counter, 1)
		mm_want := mmGetAllReminders.GetAllRemindersMock.defaultExpectation.params
		mm_want_ptrs := mmGetAllReminders.GetAllRemindersMock.defaultExpectation.paramPtrs

		mm_got := ReminderRepositoryMockGetAllRemindersParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetAllReminders.t.Errorf("ReminderRepositoryMock.GetAllReminders got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetAllReminders.GetAllRemindersMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetAllReminders.t.Errorf("ReminderRepositoryMock.GetAllReminders got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetAllReminders.GetAllRemindersMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetAllReminders.GetAllRemindersMock.defaultExpectation.results
		if mm_results == nil {
			mmGetAllReminders.t.Fatal("No results are set for the ReminderRepositoryMock.GetAllReminders")
		}
		return (*mm_results).ra1, (*mm_results).err
	}
	if mmGetAllReminders.funcGetAllReminders != nil {
		return mmGetAllReminders.funcGetAllReminders(ctx)
	}
	mmGetAllReminders.t.Fatalf("Unexpected call to ReminderRepositoryMock.GetAllReminders. %v", ctx)
	return
}

// GetAllRemindersAfterCounter returns a count of finished ReminderRepositoryMock.GetAllReminders invocations
func (mmGetAllReminders *ReminderRepositoryMock) GetAllRemindersAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAllReminders.afterGetAllRemindersCounter)
}

// GetAllRemindersBeforeCounter returns a count of ReminderRepositoryMock.GetAllReminders invocations
func (mmGetAllReminders *ReminderRepositoryMock) GetAllRemindersBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAllReminders.beforeGetAllRemindersCounter)
}

// Calls returns a list of arguments used in each call to ReminderRepositoryMock.GetAllReminders.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetAllReminders *mReminderRepositoryMockGetAllReminders) Calls() []*ReminderRepositoryMockGetAllRemindersParams {
	mmGetAllReminders.mutex.RLock()

	argCopy := make([]*ReminderRepositoryMockGetAllRemindersParams, len(mmGetAllReminders.callArgs))
	copy(argCopy, mmGetAllReminders.callArgs)

	mmGetAllReminders.mutex.RUnlock()

	return argCopy
}

// MinimockGetAllRemindersDone returns true if the count of the GetAllReminders invocations corresponds
// the number of defined expectations
func (m *ReminderRepositoryMock) MinimockGetAllRemindersDone() bool {
	if m.GetAllRemindersMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetAllRemindersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetAllRemindersMock.invocationsDone()
}

// MinimockGetAllRemindersInspect logs each unmet expectation
func (m *ReminderRepositoryMock) MinimockGetAllRemindersInspect() {
	for _, e := range m.GetAllRemindersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ReminderRepositoryMock.GetAllReminders at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetAllRemindersCounter := mm_atomic.LoadUint64(&m.afterGetAllRemindersCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetAllRemindersMock.defaultExpectation != nil && afterGetAllRemindersCounter < 1 {
		if m.GetAllRemindersMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ReminderRepositoryMock.GetAllReminders at\n%s", m.GetAllRemindersMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ReminderRepositoryMock.GetAllReminders at\n%s with params: %#v", m.GetAllRemindersMock.defaultExpectation.expectationOrigins.origin, *m.GetAllRemindersMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetAllReminders != nil && afterGetAllRemindersCounter < 1 {
		m.t.Errorf("Expected call to ReminderRepositoryMock.GetAllReminders at\n%s", m.funcGetAllRemindersOrigin)
	}

	if !m.GetAllRemindersMock.invocationsDone() && afterGetAllRemindersCounter > 0 {
		m.t.Errorf("Expected %d calls to ReminderRepositoryMock.GetAllReminders at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetAllRemindersMock.expectedInvocations), m.GetAllRemindersMock.expectedInvocationsOrigin, afterGetAllRemindersCounter)
	}
}

type mReminderRepositoryMockGetReminderByID struct {
	optional           bool
	mock               *ReminderRepositoryMock
	defaultExpectation *ReminderRepositoryMockGetReminderByIDExpectation
	expectations       []*ReminderRepositoryMockGetReminderByIDExpectation

	callArgs []*ReminderRepositoryMockGetReminderByIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ReminderRepositoryMockGetReminderByIDExpectation specifies expectation struct of the ReminderRepository.GetReminderByID
type ReminderRepositoryMockGetReminderByIDExpectation struct {
	mock               *ReminderRepositoryMock
	params             *ReminderRepositoryMockGetReminderByIDParams
	paramPtrs          *ReminderRepositoryMockGetReminderByIDParamPtrs
	expectationOrigins ReminderRepositoryMockGetReminderByIDExpectationOrigins
	results            *ReminderRepositoryMockGetReminderByIDResults
	returnOrigin       string
	Counter            uint64
}

// ReminderRepositoryMockGetReminderByIDParams contains parameters of the ReminderRepository.GetReminderByID
type ReminderRepositoryMockGetReminderByIDParams struct {
	ctx        context.Context
	reminderID reminder_id_model.ReminderID
}

// ReminderRepositoryMockGetReminderByIDParamPtrs contains pointers to parameters of the ReminderRepository.GetReminderByID
type ReminderRepositoryMockGetReminderByIDParamPtrs struct {
	ctx        *context.Context
	reminderID *reminder_id_model.ReminderID
}

// ReminderRepositoryMockGetReminderByIDResults contains results of the ReminderRepository.GetReminderByID
type ReminderRepositoryMockGetReminderByIDResults struct {
	r1  Reminder
	err error
}

// ReminderRepositoryMockGetReminderByIDOrigins contains origins of expectations of the ReminderRepository.GetReminderByID
type ReminderRepositoryMockGetReminderByIDExpectationOrigins struct {
	origin           string
	originCtx        string
	originReminderID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetReminderByID *mReminderRepositoryMockGetReminderByID) Optional() *mReminderRepositoryMockGetReminderByID {
	mmGetReminderByID.optional = true
	return mmGetReminderByID
}

// Expect sets up expected params for ReminderRepository.GetReminderByID
func (mmGetReminderByID *mReminderRepositoryMockGetReminderByID) Expect(ctx context.Context, reminderID reminder_id_model.ReminderID) *mReminderRepositoryMockGetReminderByID {
	if mmGetReminderByID.mock.funcGetReminderByID != nil {
		mmGetReminderByID.mock.t.Fatalf("ReminderRepositoryMock.GetReminderByID mock is already set by Set")
	}

	if mmGetReminderByID.defaultExpectation == nil {
		mmGetReminderByID.defaultExpectation = &ReminderRepositoryMockGetReminderByIDExpectation{}
	}

	if mmGetReminderByID.defaultExpectation.paramPtrs != nil {
		mmGetReminderByID.mock.t.Fatalf("ReminderRepositoryMock.GetReminderByID mock is already set by ExpectParams functions")
	}

	mmGetReminderByID.defaultExpectation.params = &ReminderRepositoryMockGetReminderByIDParams{ctx, reminderID}
	mmGetReminderByID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetReminderByID.expectations {
		if minimock.Equal(e.params, mmGetReminderByID.defaultExpectation.params) {
			mmGetReminderByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetReminderByID.defaultExpectation.params)
		}
	}

	return mmGetReminderByID
}

// ExpectCtxParam1 sets up expected param ctx for ReminderRepository.GetReminderByID
func (mmGetReminderByID *mReminderRepositoryMockGetReminderByID) ExpectCtxParam1(ctx context.Context) *mReminderRepositoryMockGetReminderByID {
	if mmGetReminderByID.mock.funcGetReminderByID != nil {
		mmGetReminderByID.mock.t.Fatalf("ReminderRepositoryMock.GetReminderByID mock is already set by Set")
	}

	if mmGetReminderByID.defaultExpectation == nil {
		mmGetReminderByID.defaultExpectation = &ReminderRepositoryMockGetReminderByIDExpectation{}
	}

	if mmGetReminderByID.defaultExpectation.params != nil {
		mmGetReminderByID.mock.t.Fatalf("ReminderRepositoryMock.GetReminderByID mock is already set by Expect")
	}

	if mmGetReminderByID.defaultExpectation.paramPtrs == nil {
		mmGetReminderByID.defaultExpectation.paramPtrs = &ReminderRepositoryMockGetReminderByIDParamPtrs{}
	}
	mmGetReminderByID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetReminderByID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetReminderByID
}

// ExpectReminderIDParam2 sets up expected param reminderID for ReminderRepository.GetReminderByID
func (mmGetReminderByID *mReminderRepositoryMockGetReminderByID) ExpectReminderIDParam2(reminderID reminder_id_model.ReminderID) *mReminderRepositoryMockGetReminderByID {
	if mmGetReminderByID.mock.funcGetReminderByID != nil {
		mmGetReminderByID.mock.t.Fatalf("ReminderRepositoryMock.GetReminderByID mock is already set by Set")
	}

	if mmGetReminderByID.defaultExpectation == nil {
		mmGetReminderByID.defaultExpectation = &ReminderRepositoryMockGetReminderByIDExpectation{}
	}

	if mmGetReminderByID.defaultExpectation.params != nil {
		mmGetReminderByID.mock.t.Fatalf("ReminderRepositoryMock.GetReminderByID mock is already set by Expect")
	}

	if mmGetReminderByID.defaultExpectation.paramPtrs == nil {
		mmGetReminderByID.defaultExpectation.paramPtrs = &ReminderRepositoryMockGetReminderByIDParamPtrs{}
	}
	mmGetReminderByID.defaultExpectation.paramPtrs.reminderID = &reminderID
	mmGetReminderByID.defaultExpectation.expectationOrigins.originReminderID = minimock.CallerInfo(1)

	return mmGetReminderByID
}

// Inspect accepts an inspector function that has same arguments as the ReminderRepository.GetReminderByID
func (mmGetReminderByID *mReminderRepositoryMockGetReminderByID) Inspect(f func(ctx context.Context, reminderID reminder_id_model.ReminderID)) *mReminderRepositoryMockGetReminderByID {
	if mmGetReminderByID.mock.inspectFuncGetReminderByID != nil {
		mmGetReminderByID.mock.t.Fatalf("Inspect function is already set for ReminderRepositoryMock.GetReminderByID")
	}

	mmGetReminderByID.mock.inspectFuncGetReminderByID = f

	return mmGetReminderByID
}

// Return sets up results that will be returned by ReminderRepository.GetReminderByID
func (mmGetReminderByID *mReminderRepositoryMockGetReminderByID) Return(r1 Reminder, err error) *ReminderRepositoryMock {
	if mmGetReminderByID.mock.funcGetReminderByID != nil {
		mmGetReminderByID.mock.t.Fatalf("ReminderRepositoryMock.GetReminderByID mock is already set by Set")
	}

	if mmGetReminderByID.defaultExpectation == nil {
		mmGetReminderByID.defaultExpectation = &ReminderRepositoryMockGetReminderByIDExpectation{mock: mmGetReminderByID.mock}
	}
	mmGetReminderByID.defaultExpectation.results = &ReminderRepositoryMockGetReminderByIDResults{r1, err}
	mmGetReminderByID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetReminderByID.mock
}

// Set uses given function f to mock the ReminderRepository.GetReminderByID method
func (mmGetReminderByID *mReminderRepositoryMockGetReminderByID) Set(f func(ctx context.Context, reminderID reminder_id_model.ReminderID) (r1 Reminder, err error)) *ReminderRepositoryMock {
	if mmGetReminderByID.defaultExpectation != nil {
		mmGetReminderByID.mock.t.Fatalf("Default expectation is already set for the ReminderRepository.GetReminderByID method")
	}

	if len(mmGetReminderByID.expectations) > 0 {
		mmGetReminderByID.mock.t.Fatalf("Some expectations are already set for the ReminderRepository.GetReminderByID method")
	}

	mmGetReminderByID.mock.funcGetReminderByID = f
	mmGetReminderByID.mock.funcGetReminderByIDOrigin = minimock.CallerInfo(1)
	return mmGetReminderByID.mock
}

// When sets expectation for the ReminderRepository.GetReminderByID which will trigger the result defined by the following
// Then helper
func (mmGetReminderByID *mReminderRepositoryMockGetReminderByID) When(ctx context.Context, reminderID reminder_id_model.ReminderID) *ReminderRepositoryMockGetReminderByIDExpectation {
	if mmGetReminderByID.mock.funcGetReminderByID != nil {
		mmGetReminderByID.mock.t.Fatalf("ReminderRepositoryMock.GetReminderByID mock is already set by Set")
	}

	expectation := &ReminderRepositoryMockGetReminderByIDExpectation{
		mock:               mmGetReminderByID.mock,
		params:             &ReminderRepositoryMockGetReminderByIDParams{ctx, reminderID},
		expectationOrigins: ReminderRepositoryMockGetReminderByIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetReminderByID.expectations = append(mmGetReminderByID.expectations, expectation)
	return expectation
}

// Then sets up ReminderRepository.GetReminderByID return parameters for the expectation previously defined by the When method
func (e *ReminderRepositoryMockGetReminderByIDExpectation) Then(r1 Reminder, err error) *ReminderRepositoryMock {
	e.results = &ReminderRepositoryMockGetReminderByIDResults{r1, err}
	return e.mock
}

// Times sets number of times ReminderRepository.GetReminderByID should be invoked
func (mmGetReminderByID *mReminderRepositoryMockGetReminderByID) Times(n uint64) *mReminderRepositoryMockGetReminderByID {
	if n == 0 {
		mmGetReminderByID.mock.t.Fatalf("Times of ReminderRepositoryMock.GetReminderByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetReminderByID.expectedInvocations, n)
	mmGetReminderByID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetReminderByID
}

func (mmGetReminderByID *mReminderRepositoryMockGetReminderByID) invocationsDone() bool {
	if len(mmGetReminderByID.expectations) == 0 && mmGetReminderByID.defaultExpectation == nil && mmGetReminderByID.mock.funcGetReminderByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetReminderByID.mock.afterGetReminderByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetReminderByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetReminderByID implements ReminderRepository
func (mmGetReminderByID *ReminderRepositoryMock) GetReminderByID(ctx context.Context, reminderID reminder_id_model.ReminderID) (r1 Reminder, err error) {
	mm_atomic.AddUint64(&mmGetReminderByID.beforeGetReminderByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetReminderByID.afterGetReminderByIDCounter, 1)

	mmGetReminderByID.t.Helper()

	if mmGetReminderByID.inspectFuncGetReminderByID != nil {
		mmGetReminderByID.inspectFuncGetReminderByID(ctx, reminderID)
	}

	mm_params := ReminderRepositoryMockGetReminderByIDParams{ctx, reminderID}

	// Record call args
	mmGetReminderByID.GetReminderByIDMock.mutex.Lock()
	mmGetReminderByID.GetReminderByIDMock.callArgs = append(mmGetReminderByID.GetReminderByIDMock.callArgs, &mm_params)
	mmGetReminderByID.GetReminderByIDMock.mutex.Unlock()

	for _, e := range mmGetReminderByID.GetReminderByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.r1, e.results.err
		}
	}

	if mmGetReminderByID.GetReminderByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetReminderByID.GetReminderByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetReminderByID.GetReminderByIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetReminderByID.GetReminderByIDMock.defaultExpectation.paramPtrs

		mm_got := ReminderRepositoryMockGetReminderByIDParams{ctx, reminderID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetReminderByID.t.Errorf("ReminderRepositoryMock.GetReminderByID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetReminderByID.GetReminderByIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.reminderID != nil && !minimock.Equal(*mm_want_ptrs.reminderID, mm_got.reminderID) {
				mmGetReminderByID.t.Errorf("ReminderRepositoryMock.GetReminderByID got unexpected parameter reminderID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetReminderByID.GetReminderByIDMock.defaultExpectation.expectationOrigins.originReminderID, *mm_want_ptrs.reminderID, mm_got.reminderID, minimock.Diff(*mm_want_ptrs.reminderID, mm_got.reminderID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetReminderByID.t.Errorf("ReminderRepositoryMock.GetReminderByID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetReminderByID.GetReminderByIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetReminderByID.GetReminderByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetReminderByID.t.Fatal("No results are set for the ReminderRepositoryMock.GetReminderByID")
		}
		return (*mm_results).r1, (*mm_results).err
	}
	if mmGetReminderByID.funcGetReminderByID != nil {
		return mmGetReminderByID.funcGetReminderByID(ctx, reminderID)
	}
	mmGetReminderByID.t.Fatalf("Unexpected call to ReminderRepositoryMock.GetReminderByID. %v %v", ctx, reminderID)
	return
}

// GetReminderByIDAfterCounter returns a count of finished ReminderRepositoryMock.GetReminderByID invocations
func (mmGetReminderByID *ReminderRepositoryMock) GetReminderByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetReminderByID.afterGetReminderByIDCounter)
}

// GetReminderByIDBeforeCounter returns a count of ReminderRepositoryMock.GetReminderByID invocations
func (mmGetReminderByID *ReminderRepositoryMock) GetReminderByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetReminderByID.beforeGetReminderByIDCounter)
}

// Calls returns a list of arguments used in each call to ReminderRepositoryMock.GetReminderByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetReminderByID *mReminderRepositoryMockGetReminderByID) Calls() []*ReminderRepositoryMockGetReminderByIDParams {
	mmGetReminderByID.mutex.RLock()

	argCopy := make([]*ReminderRepositoryMockGetReminderByIDParams, len(mmGetReminderByID.callArgs))
	copy(argCopy, mmGetReminderByID.callArgs)

	mmGetReminderByID.mutex.RUnlock()

	return argCopy
}

// MinimockGetReminderByIDDone returns true if the count of the GetReminderByID invocations corresponds
// the number of defined expectations
func (m *ReminderRepositoryMock) MinimockGetReminderByIDDone() bool {
	if m.GetReminderByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetReminderByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetReminderByIDMock.invocationsDone()
}

// MinimockGetReminderByIDInspect logs each unmet expectation
func (m *ReminderRepositoryMock) MinimockGetReminderByIDInspect() {
	for _, e := range m.GetReminderByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ReminderRepositoryMock.GetReminderByID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetReminderByIDCounter := mm_atomic.LoadUint64(&m.afterGetReminderByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetReminderByIDMock.defaultExpectation != nil && afterGetReminderByIDCounter < 1 {
		if m.GetReminderByIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ReminderRepositoryMock.GetReminderByID at\n%s", m.GetReminderByIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ReminderRepositoryMock.GetReminderByID at\n%s with params: %#v", m.GetReminderByIDMock.defaultExpectation.expectationOrigins.origin, *m.GetReminderByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetReminderByID != nil && afterGetReminderByIDCounter < 1 {
		m.t.Errorf("Expected call to ReminderRepositoryMock.GetReminderByID at\n%s", m.funcGetReminderByIDOrigin)
	}

	if !m.GetReminderByIDMock.invocationsDone() && afterGetReminderByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to ReminderRepositoryMock.GetReminderByID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetReminderByIDMock.expectedInvocations), m.GetReminderByIDMock.expectedInvocationsOrigin, afterGetReminderByIDCounter)
	}
}

type mReminderRepositoryMockSaveReminder struct {
	optional           bool
	mock               *ReminderRepositoryMock
	defaultExpectation *ReminderRepositoryMockSaveReminderExpectation
	expectations       []*ReminderRepositoryMockSaveReminderExpectation

	callArgs []*ReminderRepositoryMockSaveReminderParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ReminderRepositoryMockSaveReminderExpectation specifies expectation struct of the ReminderRepository.SaveReminder
type ReminderRepositoryMockSaveReminderExpectation struct {
	mock               *ReminderRepositoryMock
	params             *ReminderRepositoryMockSaveReminderParams
	paramPtrs          *ReminderRepositoryMockSaveReminderParamPtrs
	expectationOrigins ReminderRepositoryMockSaveReminderExpectationOrigins
	results            *ReminderRepositoryMockSaveReminderResults
	returnOrigin       string
	Counter            uint64
}

// ReminderRepositoryMockSaveReminderParams contains parameters of the ReminderRepository.SaveReminder
type ReminderRepositoryMockSaveReminderParams struct {
	ctx      context.Context
	reminder Reminder
}

// ReminderRepositoryMockSaveReminderParamPtrs contains pointers to parameters of the ReminderRepository.SaveReminder
type ReminderRepositoryMockSaveReminderParamPtrs struct {
	ctx      *context.Context
	reminder *Reminder
}

// ReminderRepositoryMockSaveReminderResults contains results of the ReminderRepository.SaveReminder
type ReminderRepositoryMockSaveReminderResults struct {
	err error
}

// ReminderRepositoryMockSaveReminderOrigins contains origins of expectations of the ReminderRepository.SaveReminder
type ReminderRepositoryMockSaveReminderExpectationOrigins struct {
	origin         string
	originCtx      string
	originReminder string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSaveReminder *mReminderRepositoryMockSaveReminder) Optional() *mReminderRepositoryMockSaveReminder {
	mmSaveReminder.optional = true
	return mmSaveReminder
}

// Expect sets up expected params for ReminderRepository.SaveReminder
func (mmSaveReminder *mReminderRepositoryMockSaveReminder) Expect(ctx context.Context, reminder Reminder) *mReminderRepositoryMockSaveReminder {
	if mmSaveReminder.mock.funcSaveReminder != nil {
		mmSaveReminder.mock.t.Fatalf("ReminderRepositoryMock.SaveReminder mock is already set by Set")
	}

	if mmSaveReminder.defaultExpectation == nil {
		mmSaveReminder.defaultExpectation = &ReminderRepositoryMockSaveReminderExpectation{}
	}

	if mmSaveReminder.defaultExpectation.paramPtrs != nil {
		mmSaveReminder.mock.t.Fatalf("ReminderRepositoryMock.SaveReminder mock is already set by ExpectParams functions")
	}

	mmSaveReminder.defaultExpectation.params = &ReminderRepositoryMockSaveReminderParams{ctx, reminder}
	mmSaveReminder.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSaveReminder.expectations {
		if minimock.Equal(e.params, mmSaveReminder.defaultExpectation.params) {
			mmSaveReminder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSaveReminder.defaultExpectation.params)
		}
	}

	return mmSaveReminder
}

// ExpectCtxParam1 sets up expected param ctx for ReminderRepository.SaveReminder
func (mmSaveReminder *mReminderRepositoryMockSaveReminder) ExpectCtxParam1(ctx context.Context) *mReminderRepositoryMockSaveReminder {
	if mmSaveReminder.mock.funcSaveReminder != nil {
		mmSaveReminder.mock.t.Fatalf("ReminderRepositoryMock.SaveReminder mock is already set by Set")
	}

	if mmSaveReminder.defaultExpectation == nil {
		mmSaveReminder.defaultExpectation = &ReminderRepositoryMockSaveReminderExpectation{}
	}

	if mmSaveReminder.defaultExpectation.params != nil {
		mmSaveReminder.mock.t.Fatalf("ReminderRepositoryMock.SaveReminder mock is already set by Expect")
	}

	if mmSaveReminder.defaultExpectation.paramPtrs == nil {
		mmSaveReminder.defaultExpectation.paramPtrs = &ReminderRepositoryMockSaveReminderParamPtrs{}
	}
	mmSaveReminder.defaultExpectation.paramPtrs.ctx = &ctx
	mmSaveReminder.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSaveReminder
}

// ExpectReminderParam2 sets up expected param reminder for ReminderRepository.SaveReminder
func (mmSaveReminder *mReminderRepositoryMockSaveReminder) ExpectReminderParam2(reminder Reminder) *mReminderRepositoryMockSaveReminder {
	if mmSaveReminder.mock.funcSaveReminder != nil {
		mmSaveReminder.mock.t.Fatalf("ReminderRepositoryMock.SaveReminder mock is already set by Set")
	}

	if mmSaveReminder.defaultExpectation == nil {
		mmSaveReminder.defaultExpectation = &ReminderRepositoryMockSaveReminderExpectation{}
	}

	if mmSaveReminder.defaultExpectation.params != nil {
		mmSaveReminder.mock.t.Fatalf("ReminderRepositoryMock.SaveReminder mock is already set by Expect")
	}

	if mmSaveReminder.defaultExpectation.paramPtrs == nil {
		mmSaveReminder.defaultExpectation.paramPtrs = &ReminderRepositoryMockSaveReminderParamPtrs{}
	}
	mmSaveReminder.defaultExpectation.paramPtrs.reminder = &reminder
	mmSaveReminder.defaultExpectation.expectationOrigins.originReminder = minimock.CallerInfo(1)

	return mmSaveReminder
}

// Inspect accepts an inspector function that has same arguments as the ReminderRepository.SaveReminder
func (mmSaveReminder *mReminderRepositoryMockSaveReminder) Inspect(f func(ctx context.Context, reminder Reminder)) *mReminderRepositoryMockSaveReminder {
	if mmSaveReminder.mock.inspectFuncSaveReminder != nil {
		mmSaveReminder.mock.t.Fatalf("Inspect function is already set for ReminderRepositoryMock.SaveReminder")
	}

	mmSaveReminder.mock.inspectFuncSaveReminder = f

	return mmSaveReminder
}

// Return sets up results that will be returned by ReminderRepository.SaveReminder
func (mmSaveReminder *mReminderRepositoryMockSaveReminder) Return(err error) *ReminderRepositoryMock {
	if mmSaveReminder.mock.funcSaveReminder != nil {
		mmSaveReminder.mock.t.Fatalf("ReminderRepositoryMock.SaveReminder mock is already set by Set")
	}

	if mmSaveReminder.defaultExpectation == nil {
		mmSaveReminder.defaultExpectation = &ReminderRepositoryMockSaveReminderExpectation{mock: mmSaveReminder.mock}
	}
	mmSaveReminder.defaultExpectation.results = &ReminderRepositoryMockSaveReminderResults{err}
	mmSaveReminder.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSaveReminder.mock
}

// Set uses given function f to mock the ReminderRepository.SaveReminder method
func (mmSaveReminder *mReminderRepositoryMockSaveReminder) Set(f func(ctx context.Context, reminder Reminder) (err error)) *ReminderRepositoryMock {
	if mmSaveReminder.defaultExpectation != nil {
		mmSaveReminder.mock.t.Fatalf("Default expectation is already set for the ReminderRepository.SaveReminder method")
	}

	if len(mmSaveReminder.expectations) > 0 {
		mmSaveReminder.mock.t.Fatalf("Some expectations are already set for the ReminderRepository.SaveReminder method")
	}

	mmSaveReminder.mock.funcSaveReminder = f
	mmSaveReminder.mock.funcSaveReminderOrigin = minimock.CallerInfo(1)
	return mmSaveReminder.mock
}

// When sets expectation for the ReminderRepository.SaveReminder which will trigger the result defined by the following
// Then helper
func (mmSaveReminder *mReminderRepositoryMockSaveReminder) When(ctx context.Context, reminder Reminder) *ReminderRepositoryMockSaveReminderExpectation {
	if mmSaveReminder.mock.funcSaveReminder != nil {
		mmSaveReminder.mock.t.Fatalf("ReminderRepositoryMock.SaveReminder mock is already set by Set")
	}

	expectation := &ReminderRepositoryMockSaveReminderExpectation{
		mock:               mmSaveReminder.mock,
		params:             &ReminderRepositoryMockSaveReminderParams{ctx, reminder},
		expectationOrigins: ReminderRepositoryMockSaveReminderExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSaveReminder.expectations = append(mmSaveReminder.expectations, expectation)
	return expectation
}

// Then sets up ReminderRepository.SaveReminder return parameters for the expectation previously defined by the When method
func (e *ReminderRepositoryMockSaveReminderExpectation) Then(err error) *ReminderRepositoryMock {
	e.results = &ReminderRepositoryMockSaveReminderResults{err}
	return e.mock
}

// Times sets number of times ReminderRepository.SaveReminder should be invoked
func (mmSaveReminder *mReminderRepositoryMockSaveReminder) Times(n uint64) *mReminderRepositoryMockSaveReminder {
	if n == 0 {
		mmSaveReminder.mock.t.Fatalf("Times of ReminderRepositoryMock.SaveReminder mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSaveReminder.expectedInvocations, n)
	mmSaveReminder.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSaveReminder
}

func (mmSaveReminder *mReminderRepositoryMockSaveReminder) invocationsDone() bool {
	if len(mmSaveReminder.expectations) == 0 && mmSaveReminder.defaultExpectation == nil && mmSaveReminder.mock.funcSaveReminder == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSaveReminder.mock.afterSaveReminderCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSaveReminder.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SaveReminder implements ReminderRepository
func (mmSaveReminder *ReminderRepositoryMock) SaveReminder(ctx context.Context, reminder Reminder) (err error) {
	mm_atomic.AddUint64(&mmSaveReminder.beforeSaveReminderCounter, 1)
	defer mm_atomic.AddUint64(&mmSaveReminder.afterSaveReminderCounter, 1)

	mmSaveReminder.t.Helper()

	if mmSaveReminder.inspectFuncSaveReminder != nil {
		mmSaveReminder.inspectFuncSaveReminder(ctx, reminder)
	}

	mm_params := ReminderRepositoryMockSaveReminderParams{ctx, reminder}

	// Record call args
	mmSaveReminder.SaveReminderMock.mutex.Lock()
	mmSaveReminder.SaveReminderMock.callArgs = append(mmSaveReminder.SaveReminderMock.callArgs, &mm_params)
	mmSaveReminder.SaveReminderMock.mutex.Unlock()

	for _, e := range mmSaveReminder.SaveReminderMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSaveReminder.SaveReminderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSaveReminder.SaveReminderMock.defaultExpectation.Counter, 1)
		mm_want := mmSaveReminder.SaveReminderMock.defaultExpectation.params
		mm_want_ptrs := mmSaveReminder.SaveReminderMock.defaultExpectation.paramPtrs

		mm_got := ReminderRepositoryMockSaveReminderParams{ctx, reminder}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSaveReminder.t.Errorf("ReminderRepositoryMock.SaveReminder got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSaveReminder.SaveReminderMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.reminder != nil && !minimock.Equal(*mm_want_ptrs.reminder, mm_got.reminder) {
				mmSaveReminder.t.Errorf("ReminderRepositoryMock.SaveReminder got unexpected parameter reminder, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSaveReminder.SaveReminderMock.defaultExpectation.expectationOrigins.originReminder, *mm_want_ptrs.reminder, mm_got.reminder, minimock.Diff(*mm_want_ptrs.reminder, mm_got.reminder))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSaveReminder.t.Errorf("ReminderRepositoryMock.SaveReminder got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSaveReminder.SaveReminderMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSaveReminder.SaveReminderMock.defaultExpectation.results
		if mm_results == nil {
			mmSaveReminder.t.Fatal("No results are set for the ReminderRepositoryMock.SaveReminder")
		}
		return (*mm_results).err
	}
	if mmSaveReminder.funcSaveReminder != nil {
		return mmSaveReminder.funcSaveReminder(ctx, reminder)
	}
	mmSaveReminder.t.Fatalf("Unexpected call to ReminderRepositoryMock.SaveReminder. %v %v", ctx, reminder)
	return
}

// SaveReminderAfterCounter returns a count of finished ReminderRepositoryMock.SaveReminder invocations
func (mmSaveReminder *ReminderRepositoryMock) SaveReminderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSaveReminder.afterSaveReminderCounter)
}

// SaveReminderBeforeCounter returns a count of ReminderRepositoryMock.SaveReminder invocations
func (mmSaveReminder *ReminderRepositoryMock) SaveReminderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSaveReminder.beforeSaveReminderCounter)
}

// Calls returns a list of arguments used in each call to ReminderRepositoryMock.SaveReminder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSaveReminder *mReminderRepositoryMockSaveReminder) Calls() []*ReminderRepositoryMockSaveReminderParams {
	mmSaveReminder.mutex.RLock()

	argCopy := make([]*ReminderRepositoryMockSaveReminderParams, len(mmSaveReminder.callArgs))
	copy(argCopy, mmSaveReminder.callArgs)

	mmSaveReminder.mutex.RUnlock()

	return argCopy
}

// MinimockSaveReminderDone returns true if the count of the SaveReminder invocations corresponds
// the number of defined expectations
func (m *ReminderRepositoryMock) MinimockSaveReminderDone() bool {
	if m.SaveReminderMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SaveReminderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SaveReminderMock.invocationsDone()
}

// MinimockSaveReminderInspect logs each unmet expectation
func (m *ReminderRepositoryMock) MinimockSaveReminderInspect() {
	for _, e := range m.SaveReminderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ReminderRepositoryMock.SaveReminder at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSaveReminderCounter := mm_atomic.LoadUint64(&m.afterSaveReminderCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SaveReminderMock.defaultExpectation != nil && afterSaveReminderCounter < 1 {
		if m.SaveReminderMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ReminderRepositoryMock.SaveReminder at\n%s", m.SaveReminderMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ReminderRepositoryMock.SaveReminder at\n%s with params: %#v", m.SaveReminderMock.defaultExpectation.expectationOrigins.origin, *m.SaveReminderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSaveReminder != nil && afterSaveReminderCounter < 1 {
		m.t.Errorf("Expected call to ReminderRepositoryMock.SaveReminder at\n%s", m.funcSaveReminderOrigin)
	}

	if !m.SaveReminderMock.invocationsDone() && afterSaveReminderCounter > 0 {
		m.t.Errorf("Expected %d calls to ReminderRepositoryMock.SaveReminder at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SaveReminderMock.expectedInvocations), m.SaveReminderMock.expectedInvocationsOrigin, afterSaveReminderCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ReminderRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockDeleteReminderInspect()

			m.MinimockGetAllRemindersInspect()

			m.MinimockGetReminderByIDInspect()

			m.MinimockSaveReminderInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ReminderRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ReminderRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockDeleteReminderDone() &&
		m.MinimockGetAllRemindersDone() &&
		m.MinimockGetReminderByIDDone() &&
		m.MinimockSaveReminderDone()
}
